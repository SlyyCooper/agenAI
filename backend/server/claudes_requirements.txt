You are Peter Levels. I need you to generate a complete, working backend that I can deploy today. Write the actual code for each file, with detailed comments explaining exactly how everything works. Focus on speed and simplicity - no extra complexity.

Create a FastAPI backend that:

1. Uses Firebase Admin SDK for:
   - Auth: email/Google/Twitter login
   - Storage: direct file uploads to bucket
   - Firestore: simple JSON data storage

2. Implements Stripe for:
   - One-time payments
   - Subscriptions
   - Webhook handling

3. Environment setup:
   - Firebase service account
   - Storage bucket
   - Stripe keys
   - CORS origins

4. Generate production-ready code with:
   - Async route handlers
   - Error messages
   - Frontend integration points
   - Deployment instructions

No TypeScript types. No schemas. No services. Just working endpoints.

## Pieter Levels Essentials

Add these Pieter-style essentials:
- `ALLOWED_ORIGINS=https://agenai.app,https://www.agenai.app` for CORS (production domains)
- Simple error logging (just `console.log` is fine)
- Rate limiting on auth routes
- Basic usage metrics (track signups/payments)

**Remember his motto**: "Launch now, perfect later" ğŸš€

# Backend (Peter Levels Style)

/backend
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ auth.py      # Firebase Auth direct
â”‚   â”‚   â”œâ”€â”€ files.py     # Storage upload/download
â”‚   â”‚   â””â”€â”€ payments.py  # Stripe Checkout
â”‚   â”œâ”€â”€ firebase.py      # Init Firebase
â”‚   â””â”€â”€ config.py        # Env vars
â””â”€â”€ main.py
â”œâ”€â”€ main.py
â””â”€â”€ requirements.txt



Generate complete implementation including all necessary files, routes, and documentation.

## Minimal Required Environment Variables

Keep only these essential variables in your `.env`:

### 1. Firebase Core
- `FIREBASE_PROJECT_ID`
- `FIREBASE_PRIVATE_KEY`
- `FIREBASE_CLIENT_EMAIL`
- `FIREBASE_STORAGE_BUCKET`

### 2. Stripe Core
- `STRIPE_SECRET_KEY`
- `STRIPE_WEBHOOK_SECRET`
- `STRIPE_SUBSCRIPTION_PRICE_ID`
- `STRIPE_ONETIME_PRICE_ID`

### 3. CORS Origins
- `ALLOWED_ORIGINS`

Let me explain when to import from each file:
1. Import from userprofileAPI.ts when:
   - You need to make API calls to the backend
   - You're performing actions like fetching, creating, or updating data
2. Import from models.ts when:
   - You need type definitions for props, state, or variables
   - You're defining interfaces that extend or use these base types
   - You're typing function parameters or return values

// âœ… CORRECT USAGE:

// When making API calls:
import { getUserProfile, updateUserProfile } from '@/api/userprofileAPI';

// When defining types:
import type { UserProfileData, SubscriptionData } from '@/api/types/models';

// âŒ INCORRECT USAGE:

// Don't import types from userprofileAPI:
import type { UserProfile } from '@/api/userprofileAPI'; // Wrong!

// Don't import API functions from models:
import { getUserProfile } from '@/api/types/models'; // Wrong!